/* Mutliline comments allow to be nested! */
// Single line
// Starting with __ reserved for bultin functions that do not require
// `std` qualifier!
// Inner functions allowed as Pascal!
// due 0..4 case syntax we must avoid ambigity with floating point numbers.
// We may do it using feedback from parser, but we want to do simpler so require
// to start floating point comstant from DIGIT and not point.
// OR: reqire `case` must be INTS! OR: there is no ambigity?

// MODULES:
import std;
import std.io.{ open, close, read, write };
import std.io.*; // everything

// In Cm every variable MUST be initalized prior use!
// `out` keyword. For `new` you must init with init every member in list or 
// init value come from struct def. BUT! must init every member!
// AND every function MUSt have a return in any control flow!

// SOLVED: there is invisible package `` with such definitions that is imported ALWAYS.
// not clear: `int` is just typedef for int32 or int16 or int 64.
// and it is in std. But types like `char`(unsigned int32?), `byte` (unsigned int8) and `int`, `bool`(int) are in global space always!!!

// GOTO:
// break for labeled cycles!
outer_loop:
    for var i = 0; i < 10; i += 1
    {
        for var j = 0; j < 10; j += 1
        {
            if (i + j) mod 13 == 7
            {
                break outer_loop;
            }
        }
    }

// CONVENTION:
//  Type names start from capital!
type LessThan = fn (x: int): bool;

// STRUCTS
// short-hand: struct point {}
type Point = struct
{
    x, y: int = 0, 0;
};

// May do even this:
// Handle is pointer to struct!
type Handle = struct { __reserved: int} *;

// ENUMS
type Error = enum
{
    CantOpen, // == 0
    CantRead,
    CantClose,
};

var e = Error.CantOpen;

// TUPLES
type div_t = (int, int);
type pdiv_t = div_t*;

// Pointer TYPEDEF grammar:
// BASETYPE [*...];

// Function that is just expression this syntax allowed!
// return type deduced as type of expression!
fn div(x, y: int) = (x / y, x % y);

// default return value is `void`
fn main()
{
    // list initalization:
    var x, y = 10, 20;

    var u1: unsigned int = 14;
    var a = 12i; // int
    var b = 12i64; // int64
    var c = 32u32; // unsigned int32
    var s1 = 15;
    var q = u1 + s1; // NOT allowed to mix signed/unsigned! except of probably << and >>

    std.printf("%i %i", x, y);
}

// void*: allowed arithmetics (add/substract as it is byte ptr) but type cast 
// must be before any dereference.

fn sumInts(int n, ..): int
{
    // it hase type `void*`
    // `__va_offset()` is biltion function with compiler support - offset to .. params
    var s = 0;
    var p = std.arg_at(__va_offset());
    // or std.first_arg()
    for var i = 0; i < n; i += 1
    {
        // Type cast:
        // (EXPR: as TYPE-DEF)
        s += *(p: as int*);
        p = std.va_move(p, sizeof(int));
    }
    std.va_stop(p);
}

// lambdas:
fn f2()
{
// array literal
    var a = {10, 5, 30, 7, 20};
// tuple literal. different types allowed in tuple.
    var b = (10, 'c', 30.0);
// struct literal
// mix named and positional initalizers!
    type StrX = struct {x: int = 0; p: int[] = null; y: int = 0; z: int = 0 };
    var s = StrX {p=new int[13], x=0, y=1, 3};
// lambda!
// bool is excessive here
    std.sort(a, sizeof(a), fn (a, b: int): bool = a < b);
}

/*out ONLY for single pointer (inderection) types! else compilation error. */
fn rand(out p: Point*)
{
// for `out` parameters compiler checks that it sets in ANY control flow.
    p->x = std.rand();
    p->y = std.rand();
}

fn f1(): int
{
    // May not init if inited with `out`
    var p: Point;

    rand(&p);

    return p.x + p.y;
}

// if statement:
if a > b
{
    printf("a");
}
elif a < b
{
    printf("b");
}
else
{
    printf("equal!");
}


// switch:
switch a + 10
{
case 5
    {
        printf("Excellent");
    }
case 2, 3
    {
        printf("BAD!");
        goto case 1;
    }
case 1
    {
        printf("VERY!!!");
    }
case 6..9, 10
    {
        if a == 10
        {
            break;
        }
    }
// else MUST be last if it is.
else
    {
        printf("uhhh...\n");
        // NO fall through!
    }
}

// goto: still available, but what to do with
// variable init? DON'T allow to jump if initialization
// of some var skipped!
