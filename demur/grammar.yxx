%require "3.0"
%define api.pure full
%define api.token.prefix {TOK_}
%define parse.error verbose
%define parse.lac full

%code requires {
#include "grammar_node.hxx"
#include <stdio.h>

typedef void *yyscan_t;

namespace igor {
struct ScannerCtx {
  std::function<void(const string&)> error_fn;
};
}  // namespace
}  // %code

%code provides {
int yylex_init(yyscan_t *yyscanner);
int yylex_destroy(yyscan_t yyscanner);
int yylex(YYSTYPE *yylval, yyscan_t yyscanner);
void *yyget_extra(yyscan_t yyscanner);
void  yyset_extra(void *user_defined, yyscan_t yyscanner);
void yyset_in(FILE *in, yyscan_t yyscanner);
void yyerror(yyscan_t yyscanner, const char *msg);
}  // %code

%union {
  igor::Constant *constant;
  igor::Name *name;
}

%param {yyscan_t yyscanner}

// Terminal symbols are in CAPS by convention.
%token <constant> CONSTANT
%token <name>     NAME
%token <name>     TYPE
%token            WILDCARD  // _
%token            FN  // fn
%token            LP  // (
%token            RP  // )
%token            LC  // {
%token            RC  // }
%token            COMMA  // ,
%token            COLON  // :
%token            INVALID_CHAR

%start top

%%

top:
    %empty
  | named_fn top;

named_fn:     FN NAME fn_param body;
body:         LC RC

fn_param:
    LP RP
  | LP args RP

arg_tuple:
    NAME COLON TYPE
  | NAME COMMA arg_tuple;

args:
    arg_tuple
  | arg_tuple COMMA args;

%%

void yyerror(yyscan_t yyscanner, const char *msg) {
  auto se = reinterpret_cast<igor::ScannerCtx*>(yyget_extra(yyscanner));
  se->error_fn(msg);
}
