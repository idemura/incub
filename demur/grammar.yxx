%require "3.0"
%define api.token.prefix {TOK_}
%pure-parser

%code requires {
#include "grammar_node.hxx"
#include <stdio.h>

typedef void *yyscan_t;

namespace igor {
struct ScannerCtx {
  std::function<void(const string&)> error_fn;
};
} // namespace
}  // %code

%code provides {
int yylex_init(yyscan_t *yyscanner);
int yylex_destroy(yyscan_t yyscanner);
int yylex(YYSTYPE *yylval, yyscan_t yyscanner);
void *yyget_extra(yyscan_t yyscanner);
void  yyset_extra(void *user_defined, yyscan_t yyscanner);
void yyset_in(FILE *in, yyscan_t yyscanner);
void yyerror(yyscan_t yyscanner, const char *msg);
}  // %code

%{
// Very top of the .tab.cxx file only.
%}

%union {
  igor::Constant *constant;
  igor::Name *name;
}

%param {yyscan_t yyscanner}

// Terminal symbols are in CAPS by convention.
%token <constant> CONSTANT
%token <name>     NAME
%token <name>     TYPE
%token            WILDCARD  // _
%token            FN  // fn
%token            LP  // (
%token            RP  // )
%token            LC  // {
%token            RC  // }
%token            COMMA  // ,
%token            COLON  // :
%token            INVALID_CHAR

%start top

%%

top:      fn | NAME;
fn:       FN NAME LP params RP LC RC;
params:   NAME;

%%

void yyerror(yyscan_t yyscanner, const char *msg) {
  auto se = reinterpret_cast<igor::ScannerCtx*>(yyget_extra(yyscanner));
  se->error_fn(msg);
}
