%require "3.0"
%skeleton "lalr1.cc"

%code requires {
#include "grammar_node.hxx"

class yyFlexLexer;
}  // %code

%code provides {
namespace yy {
int yylex(parser::semantic_type *data, yyFlexLexer *lexer);
}  // namespace
}  // %code

%{
// If I put it into header, macro redifinition error will appear.
#include <FlexLexer.h>
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "yystype":
%union {
  igor::Constant *constant;
  igor::Name *name;
}

%param {yyFlexLexer *ctx}

// Terminal symbols are in CAPS by convention.
%token <constant> CONSTANT
%token <name>     NAME
%token            WILDCARD

%%
test:
  CONSTANT test         { cout << "bison found an int: " << $1->s << endl; }
  | NAME test           { cout << "bison found a string: " << $1->s << endl; }
  | CONSTANT            { cout << "bison found an int: " << $1->s << endl; }
  | NAME                { cout << "bison found a string: " << $1->s << endl; }
  ;
%%

namespace yy {
void parser::error(const string &msg) {
  cerr<<"Parse error: "<<msg<<endl;
  //std::exit(-1);
}

namespace {
string lexer_str(yyFlexLexer *lexer) {
  return {lexer->YYText(), static_cast<size_t>(lexer->YYLeng())};
}
}  // namespace

int yylex(parser::semantic_type *data, yyFlexLexer *lexer) {
  using token = parser::token;
  const auto tok_type = lexer->yylex();
  switch (tok_type) {
    case 0: break;  // EOF
    case token::CONSTANT: {
      data->constant = new igor::Constant();
      data->constant->s = lexer_str(lexer);
      break;
    }
    case token::NAME: {
      data->name = new igor::Name();
      data->name->s = lexer_str(lexer);
      break;
    }
    case token::WILDCARD:
      break;
    default: {
      cerr<<"Wrong token type "<<tok_type<<endl;
      std::exit(-1);
    }
  }
  return tok_type;
}
}  // namespace
