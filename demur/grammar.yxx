%require "3.0"
%skeleton "lalr1.cc"

%code requires {
#include "base.hxx"
#include "grammar_node.hxx"

class FlexLexer;
}  // %code

%code provides {
namespace yy {
int yylex(parser::semantic_type *data, FlexLexer *lexer);
}  // namespace
}  // %code

%{
// If I put it into header, macro redifinition error will appear.
#include <FlexLexer.h>
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "yystype":
%union {
  igor::Constant *constant;
  igor::Name *name;
}

%param {FlexLexer *ctx}
%parse-param {std::function<void(const string&)> error_fn}

// Terminal symbols are in CAPS by convention.
%token <constant> CONSTANT
%token <name>     NAME
%token <name>     TYPE
%token            WILDCARD
%token            FN
%token            LP
%token            RP
%token            LC
%token            RC

%%
top_fn:   FN NAME LP params RP LC RC ;
params:   NAME ;
%%

namespace yy {
void parser::error(const string &msg) {
  error_fn(msg);
}

namespace {
string lexer_str(FlexLexer *lexer) {
  return {lexer->YYText(), static_cast<size_t>(lexer->YYLeng())};
}
}  // namespace

int yylex(parser::semantic_type *data, FlexLexer *lexer) {
  using token = parser::token;
  const auto tok_type = lexer->yylex();
  switch (tok_type) {
    case 0: break;  // EOF
    case token::CONSTANT: {
      data->constant = new igor::Constant();
      data->constant->s = lexer_str(lexer);
      break;
    }
    case token::NAME: {
      data->name = new igor::Name();
      data->name->s = lexer_str(lexer);
      break;
    }
    case token::WILDCARD:
      break;
    default: {
      cerr<<"Wrong token type "<<tok_type<<endl;
      std::exit(-1);
    }
  }
  return tok_type;
}
}  // namespace
