%require "3.0"
%define api.pure full
%define api.token.prefix {TOK_}
%define parse.error verbose
%define parse.lac full

%code requires {
#include "grammar_node.hxx"
#include <stdio.h>

typedef void *yyscan_t;

namespace igor {
struct ScannerCtx {
  std::function<void(const string&)> error_fn;
};
}  // namespace
}  // %code

%code provides {
int yylex_init(yyscan_t *yyscanner);
int yylex_destroy(yyscan_t yyscanner);
int yylex(YYSTYPE *yylval, yyscan_t yyscanner);
void *yyget_extra(yyscan_t yyscanner);
void  yyset_extra(void *user_defined, yyscan_t yyscanner);
void yyset_in(FILE *in, yyscan_t yyscanner);
void yyerror(yyscan_t yyscanner, const char *msg);
}  // %code

%union {
  igor::Constant *constant;
  igor::Name *name;
}

%param {yyscan_t yyscanner}

// Terminal symbols are in CAPS by convention.
%token <constant> CONSTANT
%token <name>     NAME
%token <name>     TYPE
%token            FN        // fn
%token            ARROW     // =>
%token            COLON     // :
%token            COMMA     // ,
%token            DOT       // .
%token            LB        // [
%token            RB        // ]
%token            LC        // {
%token            RC        // }
%token            LP        // (
%token            RP        // )
%token            WILDCARD  // _
%token            INVALID_CHAR

%start top

%%

top:
    %empty
  | named_fn top

named_fn:     FN NAME arg_spec ret_spec body
body:         LC RC

arg_spec:
    LP RP
  | LP arg_list RP

arg:
    type_spec
  | NAME COLON type_spec
  | NAME COMMA arg

arg_list:
    arg
  | arg COMMA arg_list

ret_spec:
    %empty
  | COLON arg_list

qualifier:
    NAME DOT
  | NAME DOT qualifier

// Notation for array: Type[]. Suffix applied to the last shortest type.
// Notation for tuple: [Type1, Type2]
//
// Notation for function: T1 => T2 => RT
// This function takes two arguments of types T1 and T2 and return RT. Idea is
// taken from Haskell - uniform arg/return type. This notation is currying
// friendly.
//
// Use parenthesis to group:
//   T1 => (T2 => T3)[] => (T4 => T5)
// This function takes T1 and array of functions T2=>T3 and returns function
// T4=>T5.
//
// Generic instantiation uses parens: Templ(T1, T2).
type_spec:
    base_type
  | base_type ARROW type_spec

type_ref:
    TYPE
  | qualifier TYPE

base_type:
    type_ref
  | type_ref LP type_list RP  // Generic inst
  | LP type_spec RP
  | base_type LB RB  // Otherwise we get shit/reduce warning.
  | LB type_list RB

 type_list:
     type_spec
   | type_spec COMMA type_list

%%

void yyerror(yyscan_t yyscanner, const char *msg) {
  auto se = reinterpret_cast<igor::ScannerCtx*>(yyget_extra(yyscanner));
  se->error_fn(msg);
}
