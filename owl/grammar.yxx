%require "3.0"
%define api.pure full
%define api.token.prefix {TOK_}
%define parse.error verbose
%define parse.lac full

%expect 0  // warnings
%locations

%code requires {
#include "ast.hxx"
#include <stdio.h>

using yyscan_t = void*;
}  // %code

%code provides {
int yylex_init(yyscan_t *yyscanner);
int yylex_destroy(yyscan_t yyscanner);
int yylex(YYSTYPE *yylval, YYLTYPE *yylloc, yyscan_t yyscanner);
void *yyget_extra(yyscan_t yyscanner);
void  yyset_extra(void *user_defined, yyscan_t yyscanner);
void yyset_in(FILE *in, yyscan_t yyscanner);
void yyerror(YYLTYPE *yylloc, yyscan_t yyscanner,
             igor::AST *ast,
             igor::ErrorLog *elog,
             const char *msg);
}  // %code

%code {
using igor::wrap_unique;

namespace {
inline string move_string(string *s) {
  auto v = std::move(*s);
  delete s;
  return v;
}

template<typename T>
inline T *ast_cast(igor::AstBase* b) {
  // When I'm 100% confident no bug there, should be static_cast.
  return dynamic_cast<T*>(b);
}
}  // namespace
}

%union {
  igor::AstExpr *expr;
  igor::AstExprList *expr_list;
  igor::AstType *type;
  igor::AstArg *arg;
  igor::AstArgList *arg_list;
  igor::AstStmt *stmt;
  igor::AstStmtList *stmt_list;
  string *name;
}

%param {yyscan_t yyscanner}
%parse-param {igor::AST *ast}
%parse-param {igor::ErrorLog *elog}

// Terminal symbols are in CAPS by convention.
%token            AND         "&&"
%token            ARROW       "=>"
%token            CMP_EQ      "=="
%token            CMP_NE      "!="
%token            CMP_LT      "<"
%token            CMP_LE      "<="
%token            CMP_GT      ">"
%token            CMP_GE      ">="
%token <expr>     CONSTANT
%token            ELIF
%token            ELSE
%token            FN
%token            IF
%token            COLON       ":"
%token            COMMA       ","
%token            DOT         "."
%token            LET         "="
%token            LET_PLS     "+="
%token            LET_MNS     "-="
%token <name>     NAME
%token            OR          "||"
%token            RETURN
%token            SEMI        ";"
%token <name>     TYPE
%token <name>     WILD        "_"
%token            XOR         "^^"

%token            LB          "["
%token            RB          "]"
%token            LC          "{"
%token            RC          "}"
%token            LP          "("
%token            RP          ")"

%left OR XOR
%left AND
%right NOT

%type <name>      name
%type <name>      qualified_name
%type <type>      type
%type <type>      base_type
%type <name>      qualified_type
%type <type>      type_list
%type <arg>       arg
%type <arg_list>  arg_list
%type <arg_list>  arg_spec
%type <arg_list>  ret_spec
%type <expr_list> expr_list
%type <expr>      expr
%type <expr>      prime
%type <expr>      call
%type <stmt>      stmt
%type <stmt_list> stmt_list
%type <stmt_list> body

%destructor { delete $$; } <*>

%start module

%%

module:
%empty |
function module

name:
NAME { $$ = $1; } |
WILD { $$ = $1; }

qualified_name:
name { $$ = $1; } |
NAME DOT qualified_name {
  $$ = new string(move_string($1) + "/" + move_string($3));
}

// *** Function grammar:
function:
FN NAME arg_spec ret_spec body {
  auto f = std::make_unique<igor::AstFunction>();
  f->name = move_string($2);
  f->arg_list = wrap_unique($3);
  f->ret_list = wrap_unique($4);
  f->body = wrap_unique($5);
  ast->add_function(std::move(f));
}

arg_spec:
LP RP {
  $$ = new igor::AstArgList;
} |
LP arg_list RP { $$ = $2; }

arg:
// For declaration like x, y: Int. First x is just a name.
name {
  $$ = new igor::AstArg;
  $$->name = move_string($1);
} |
// No name declaration allowed by grammar. Should be rejected for arg list,
// but allowed for return spec.
type {
  $$ = new igor::AstArg;
  $$->type = wrap_unique($1);
} |
name COLON type {
  $$ = new igor::AstArg;
  $$->name = move_string($1);
  $$->type = wrap_unique($3);
}

arg_list:
arg {
  $$ = new igor::AstArgList;
  $$->args.push_back(wrap_unique($1));
} |
arg COMMA arg_list {
  $$ = $3;
  $$->args.push_back(wrap_unique($1));
}

ret_spec:
%empty {
  $$ = new igor::AstArgList;
} |
COLON arg_list { $$ = $2; }

// *** Type spec grammar:
// Notation for array: Type[]. Suffix applied to the last shortest type.
// Notation for tuple: [Type1, Type2]
//
// Notation for function: T1 => T2 => RT
// This function takes two arguments of types T1 and T2 and return RT. Idea is
// taken from Haskell - uniform arg/return type. This notation is currying
// friendly.
//
// Use parenthesis to group:
//   T1 => (T2 => T3)[] => (T4 => T5)
// This function takes T1 and array of functions T2=>T3 and returns a function
// T4=>T5.
//
// Generic instantiation uses parens: Templ(T1, T2).
type:
base_type { $$ = $1; } |
base_type ARROW type {
  if ($3->name == "/std/Function" && $3->carry) {
    $$ = $3;
    $$->args.push_back(wrap_unique($1));
  } else {
    $$ = new igor::AstType;
    $$->name = "/std/Function";
    $$->args.push_back(wrap_unique($3));
    $$->args.push_back(wrap_unique($1));
  }
}

qualified_type:
TYPE { $$ = $1; } |
NAME DOT qualified_type {
  $$ = new string(move_string($1) + "/" + move_string($3));
}

base_type:
qualified_type {
  $$ = new igor::AstType;
  $$->name = move_string($1);
} |
// Generic instance
qualified_type LP type_list RP {
  $$ = $3;
  $$->name = move_string($1);
} |
// Parens around type
LP type RP {
  $$ = $2;
  if ($$->name == "/std/Function") $$->carry = false;
} |
// Array, /std/Array
base_type LB RB {
  $$ = new igor::AstType;
  $$->name = "/std/Array";
  $$->args.push_back(wrap_unique($1));
} |
// Tuple, /std/Tuple
LB type_list RB {
  $$ = $2;
  $$->name = "/std/Tuple";
}

type_list:
type {
  $$ = new igor::AstType;
  $$->args.push_back(wrap_unique($1));
} |
type COMMA type_list {
  $$ = $3;
  $$->args.push_back(wrap_unique($1));
}

// *** Body grammar:
body:
LC stmt_list RC { $$ = $2; }

stmt_list:
%empty {
  $$ = new igor::AstStmtList;
} |
stmt_list stmt {
  $$ = $1;
  $$->stmts.push_back(wrap_unique($2));
}

stmt:
RETURN expr_list SEMI {
  $$ = new igor::AstStmtReturn(wrap_unique($2));
} |
expr LET expr SEMI {
  $$ = new igor::AstStmtLet(wrap_unique($1), wrap_unique($3));
} |
expr LET_PLS expr SEMI {
  $$ = new igor::AstStmtLet(wrap_unique($1), wrap_unique($3));
} |
expr LET_MNS expr SEMI {
  $$ = new igor::AstStmtLet(wrap_unique($1), wrap_unique($3));
} |
expr SEMI {
  $$ = new igor::AstStmtExpr(wrap_unique($1));
}

// *** Expression grammar:
expr_list:
%empty {
  $$ = new igor::AstExprList;
} |
expr {
  $$ = new igor::AstExprList;
  $$->exprs.push_back(wrap_unique($1));
} |
expr COMMA expr_list {
  $$ = $3;
  $$->exprs.push_back(wrap_unique($1));
}

expr:
NOT expr {
  $$ = new igor::AstExprNot(wrap_unique($2));
} |
expr AND expr {
  $$ = new igor::AstExprAnd(wrap_unique($1), wrap_unique($3));
} |
expr OR expr {
  $$ = new igor::AstExprOr(wrap_unique($1), wrap_unique($3));
} |
expr XOR expr {
  $$ = new igor::AstExprXor(wrap_unique($1), wrap_unique($3));
} |
call {
  $$ = $1;
}

call:
prime { $$ = $1; } |
call LB expr RB {
  $$ = new igor::AstExprAt(wrap_unique($1), wrap_unique($3));
} |
call LP expr_list RP {
  $$ = new igor::AstExprCall(wrap_unique($1), wrap_unique($3));
}

prime:
qualified_name {
  $$ = new igor::AstExprVar(move_string($1));
} |
LP expr RP { $$ = $2; } |
CONSTANT { $$ = $1; }

%%

void yyerror(YYLTYPE *yylloc, yyscan_t yyscanner,
             igor::AST *ast,
             igor::ErrorLog *elog,
             const char *msg) {
  elog->error(yylloc->first_line, yylloc->first_column).os()<<msg;
}
