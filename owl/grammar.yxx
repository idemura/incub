%require "3.0"
%define api.pure full
%define api.token.prefix {TOK_}
%define parse.error verbose
%define parse.lac full

%expect 0  // warnings
%locations

%code requires {
#include "ast.hxx"
#include <stdio.h>

using yyscan_t = void*;
}  // %code

%code provides {
int yylex_init(yyscan_t *yyscanner);
int yylex_destroy(yyscan_t yyscanner);
int yylex(YYSTYPE *yylval, YYLTYPE *yylloc, yyscan_t yyscanner);
void *yyget_extra(yyscan_t yyscanner);
void  yyset_extra(void *user_defined, yyscan_t yyscanner);
void yyset_in(FILE *in, yyscan_t yyscanner);
void yyerror(YYLTYPE *yylloc, yyscan_t yyscanner,
             igor::AST *ast,
             igor::ErrorLog *elog,
             const char *msg);
}  // %code

%code {
using igor::wrap_unique;

namespace {
inline string move_string(string *s) {
  auto v = std::move(*s);
  delete s;
  return v;
}
}  // namespace
}

%union {
  igor::AstConstant *constant;
  igor::AstFunction *function;
  igor::AstType *type;
  igor::AstArg *arg;
  igor::AstArgList *arg_list;
  string *name;
}

%param {yyscan_t yyscanner}
%parse-param {igor::AST *ast}
%parse-param {igor::ErrorLog *elog}

// Terminal symbols are in CAPS by convention.
%token <constant> CONSTANT
%token <name>     NAME
%token <name>     TYPE
%token <name>     WILD      // _
%token            ELIF      // elif
%token            ELSE      // else
%token            FN        // fn
%token            IF        // if
%token            RETURN    // return
%token            ARROW     // =>
%token            COLON     // :
%token            COMMA     // ,
%token            DOT       // .
%token            LET       // =
%token            LET_PLS   // +=
%token            LET_MNS   // -=
%token            SEMI      // ;
%token            LB        // [
%token            RB        // ]
%token            LC        // {
%token            RC        // }
%token            LP        // (
%token            RP        // )

%type <name>      name
%type <name>      qualified_name
%type <function>  function
%type <type>      type
%type <type>      base_type
%type <type>      qualified_type
%type <type>      type_spec
%type <type>      type_list
%type <arg>       arg
%type <arg_list>  arg_list
%type <arg_list>  arg_spec
%type <arg_list>  ret_spec

%destructor { delete $$; } <*>

%start module

%%

module:
    %empty
  | function module

name:
    NAME { $$ = $1; }
  | WILD { $$ = $1; }

qualified_name:
    name { $$ = $1; }
  | NAME DOT qualified_name
{
  $$ = new string(move_string($1) + "/" + move_string($3));
}

// *** Function grammar:
function:
    FN NAME arg_spec ret_spec body
{
  $$ = new igor::AstFunction;
  $$->name = move_string($2);
  $$->arg_list = wrap_unique($3);
  $$->ret_list = wrap_unique($4);
  ast->add_function(wrap_unique($$));
}

arg_spec:
    LP RP { $$ = new igor::AstArgList; }
  | LP arg_list RP { $$ = $2; }

arg:
    // For declaration like x, y: Int. First x is just a name.
    name
{
  $$ = new igor::AstArg;
  $$->name = move_string($1);
}
  // No name declaration allowed by grammar. Should be rejected for arg list,
  // but allowed for return spec.
  | type
{
  $$ = new igor::AstArg;
  $$->type = wrap_unique($1);
}
  | name COLON type
{
  $$ = new igor::AstArg;
  $$->name = move_string($1);
  $$->type = wrap_unique($3);
}

arg_list:
    arg
{
  $$ = new igor::AstArgList;
  $$->args.push_back(wrap_unique($1));
}
  | arg COMMA arg_list
{
  $$ = $3;
  $$->args.push_back(wrap_unique($1));
}

ret_spec:
    %empty { $$ = new igor::AstArgList; }
  | COLON arg_list { $$ = $2; }

// *** Type spec grammar:
// Notation for array: Type[]. Suffix applied to the last shortest type.
// Notation for tuple: [Type1, Type2]
//
// Notation for function: T1 => T2 => RT
// This function takes two arguments of types T1 and T2 and return RT. Idea is
// taken from Haskell - uniform arg/return type. This notation is currying
// friendly.
//
// Use parenthesis to group:
//   T1 => (T2 => T3)[] => (T4 => T5)
// This function takes T1 and array of functions T2=>T3 and returns a function
// T4=>T5.
//
// Generic instantiation uses parens: Templ(T1, T2).
type: type_spec { $$ = $1; }

type_spec:
    base_type { $$ = $1; }
  | base_type ARROW type_spec
{
  if ($3->name == "/std/Function" && $3->carry) {
    $$ = $3;
    $$->args.push_back(wrap_unique($1));
  } else {
    $$ = new igor::AstType;
    $$->name = "/std/Function";
    $$->args.push_back(wrap_unique($3));
    $$->args.push_back(wrap_unique($1));
  }
}

qualified_type:
    TYPE
{
  $$ = new igor::AstType;
  $$->name = move_string($1);
}
  | NAME DOT qualified_type
{
  $$ = $3;
  $$->name = move_string($1) + "/" + $$->name;
}

base_type:
    qualified_type { $$ = $1; }
  | qualified_type LP type_list RP  // Generic instance
{
  $$ = $3;
  if (!$$->name.empty()) {
    elog->error(0, 0).os()<<"internal error: <type_list> name is not empty";
    YYABORT;
  }
  $$->name = std::move($1->name);
  delete $1;
}
  | LP type_spec RP  // Parens around type
{
  $$ = $2;
  if ($$->name == "/std/Function") {
    $$->carry = false;
  }
}
  | base_type LB RB  // Array, /std/Array
{
  $$ = new igor::AstType;
  $$->name = "/std/Array";
  $$->args.push_back(wrap_unique($1));
}
  | LB type_list RB  // Tuple, /std/Tuple
{
  $$ = $2;
  if (!$$->name.empty()) {
    elog->error(0, 0).os()<<"internal error: <type_list> name is not empty";
    YYABORT;
  }
  $$->name = "/std/Tuple";
}

 type_list:
     type_spec
{
  $$ = new igor::AstType;
  $$->args.push_back(wrap_unique($1));
}
   | type_spec COMMA type_list
{
  $$ = $3;
  $$->args.push_back(wrap_unique($1));
}

// *** Body grammar:
body:
  LC stmt_list RC

stmt_list:
    %empty
  | stmt stmt_list

stmt:
    RETURN SEMI
  | RETURN expr_list SEMI
  | expr SEMI

// *** Expression grammar:
expr_list:
    expr
  | expr COMMA expr_list

expr:
    val_expr
  | val_expr assign val_expr

assign:
    LET
  | LET_PLS
  | LET_MNS

val_expr:
    qualified_name { delete $1; }

%%

void yyerror(YYLTYPE *yylloc, yyscan_t yyscanner,
             igor::AST *ast,
             igor::ErrorLog *elog,
             const char *msg) {
  elog->error(yylloc->first_line, yylloc->first_column).os()<<msg;
}
